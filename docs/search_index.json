[
["index.html", "Working with vector data 1 Working with vector data in R", " Working with vector data D March 1 Working with vector data in R In this module of the workshop we are going to work with vector data (points, lines and polygons). R has an extraordinary potential to handle this data and perform complex spatial operations like other Geographic Information Systems (GIS) software. Here you will find a link to: * Data. Download the zip file and store it into a data/ folder from your Rstudio project. * Slides. We will explore the capacities of R to handle and manipulate vector data through two worked examples: Hello, world! Animal oceanographers "],
["hello-world.html", "2 Hello, world! 2.1 Importing vector data 2.2 Coordinate Reference Systems (CRS) 2.3 Geographic subset 2.4 Import vector layer: point data 2.5 Spatial overlap 2.6 Interactive maps", " 2 Hello, world! 2.1 Importing vector data 2.1.1 Spatial data formats The Geospatial Data Abstraction Library is a translator library for raster and vector geospatial data formats. We will start by loading the R package of this library and check all the vector data formats that can be imported into R library(rgdal) vector_formats &lt;- ogrDrivers() head(vector_formats) ## name long_name write copy isVector ## 1 AeronavFAA Aeronav FAA FALSE FALSE TRUE ## 2 AmigoCloud AmigoCloud TRUE FALSE TRUE ## 3 ARCGEN Arc/Info Generate FALSE FALSE TRUE ## 4 AVCBin Arc/Info Binary Coverage FALSE FALSE TRUE ## 5 AVCE00 Arc/Info E00 (ASCII) Coverage FALSE FALSE TRUE ## 6 BNA Atlas BNA TRUE FALSE TRUE You can explore vector_formats. How many different formats are available? Are you familiar with any of them? 2.1.2 Import shapefiles shapefile is a popular format used in GIS. We will import a polygon layer of the world countries extracted from Natural Earth. # Import countries countries &lt;- readOGR(dsn = &quot;data/ne/ne_110m_admin_0_countries&quot;, layer = &quot;ne_110m_admin_0_countries&quot;) ## OGR data source with driver: ESRI Shapefile ## Source: &quot;C:\\Git\\spatial_data_analysis\\data\\ne\\ne_110m_admin_0_countries&quot;, layer: &quot;ne_110m_admin_0_countries&quot; ## with 177 features ## It has 94 fields ## Integer64 fields read as strings: POP_EST NE_ID We can check the class and spatial attributes of this layer # View spatial attributes class(countries) # sp class ## [1] &quot;SpatialPolygonsDataFrame&quot; ## attr(,&quot;package&quot;) ## [1] &quot;sp&quot; And now, let’s make our first plot using base R graphics # Quick plot plot(countries, main = &quot;World countries&quot;) 2.2 Coordinate Reference Systems (CRS) You can check the CRS from your spatial object # View spatial attributes proj4string(countries) # displays the coordinate reference system (CRS) ## [1] &quot;+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0&quot; And then transform to another CRS. In this case, we transform to the Mollweide projection. This is an accurate single global projection that preserves geographic area. You can see an example of application in March et al. 2019 # Change to Mollweide projection countries_moll &lt;- spTransform(countries, CRS(&quot;+proj=moll +ellps=WGS84&quot;)) # Quick plot plot(countries_moll, col = &quot;grey80&quot;, main = &quot;World countries&quot;) 2.3 Geographic subset 2.3.1 Geographic subset by setting a bounding box First, create a bounding area for subsetting the data # Import raster package library(raster) # Set min and maximum coordinates (lon/lat) xmin &lt;- -15 xmax &lt;- 46 ymin &lt;- 28 ymax &lt;- 60 # Create an extent object e &lt;- extent(xmin, xmax, ymin, ymax) class(e) ## [1] &quot;Extent&quot; ## attr(,&quot;package&quot;) ## [1] &quot;raster&quot; Then, you can use the extent object to subset the worl map using crop() function # Geographic subset of countries by the extent defined countries_subset &lt;- crop(countries, e) plot(countries_subset) 2.3.1.1 Exercise: Make a plot of South America Tip: you can Use QGIS or Google Earth to search for coordinates 2.3.2 Geographic subset by data attributes The spatial layer of polygons has a linked attribute table, with specific information for each country. You can explore convert the @data object from countries into a data.frame and then explore the attribute data. # Convert attribute data into a data.frame df &lt;- data.frame(countries@data) # head(df) List of continents unique(countries$CONTINENT) ## [1] Oceania Africa North America ## [4] Asia South America Europe ## [7] Seven seas (open ocean) Antarctica ## 8 Levels: Africa Antarctica Asia Europe North America ... South America Subset countries from South America # Subset South America south_america &lt;- countries[countries$CONTINENT == &quot;South America&quot;,] plot(south_america, col = &quot;lightgreen&quot;, border = &quot;darkgreen&quot;, lwd=3, main = &quot;South America&quot;) extent(south_america) # You can also get your extent ## class : Extent ## xmin : -81.41094 ## xmax : -34.72999 ## ymin : -55.61183 ## ymax : 12.4373 2.4 Import vector layer: point data We will import layer “Populated places of the world” from Natural Earth # Import populated places places &lt;- readOGR(dsn = &quot;data/ne/ne_110m_populated_places_simple&quot;, layer = &quot;ne_110m_populated_places_simple&quot;) ## OGR data source with driver: ESRI Shapefile ## Source: &quot;C:\\Git\\spatial_data_analysis\\data\\ne\\ne_110m_populated_places_simple&quot;, layer: &quot;ne_110m_populated_places_simple&quot; ## with 243 features ## It has 38 fields ## Integer64 fields read as strings: ne_id # View spatial attributes class(places) ## [1] &quot;SpatialPointsDataFrame&quot; ## attr(,&quot;package&quot;) ## [1] &quot;sp&quot; extent(places) ## class : Extent ## xmin : -175.2206 ## xmax : 179.2166 ## ymin : -41.29999 ## ymax : 64.15002 crs(places) ## CRS arguments: ## +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 # Quick plot plot(places, main = &quot;Populated places&quot;) The plot is not very informative. Let’s combine with the world map # Plot together with country maps plot(countries, col = &quot;grey80&quot;, border = &quot;grey80&quot;) plot(places, pch = 20, col = &quot;darkblue&quot;, add = TRUE) 2.5 Spatial overlap The overlap between spatial layer in order to extract information from one to another is one of the most common tasks in GIS. Here, we want to plot the populated places from Europe. However, there is no information about the continent in the places layer. We will use a spatial overlay to extract information from the countries layer using the function over() # Spatial overlay ov &lt;- over(places, countries) class(ov) ## [1] &quot;data.frame&quot; We then can append the continent information into the point layer places$CONTINENT &lt;- ov$CONTINENT # head(places) Note that there are places with NA in the continent attribute. This is due to a spatial missmatch between layers in terms of resolution, more specifically because of the coarse resolution of the countries layer. There would be several alternatives: 1) use a high-res countries map, 2) calculate the nearest polygon. # Subset places and countries from Africa places_africa &lt;- places[which(places$CONTINENT == &quot;Africa&quot;),] # Plot together with country maps plot(countries, col = &quot;grey80&quot;, border = &quot;grey80&quot;) plot(places_africa, pch = 20, col = &quot;darkblue&quot;, add = TRUE) 2.6 Interactive maps Spatial datasets oftern require to conduct an interative visualization of the data. In R, we can use the leaflet library to generate a dynamic viewer. # import leaflet package library(leaflet) # create leaftet map map &lt;- leaflet(data = places) %&gt;% addProviderTiles(&quot;Esri.OceanBasemap&quot;) %&gt;% # Base map addMarkers(popup = ~name) # plot leaflet map map You can customize your map using different basemaps, add more spatial layers and much more. You can check the official package website for many examples "],
["animal-oceanographers.html", "3 Animal oceanographers 3.1 Import spatial data from CSV files 3.2 Advanced maps with ggplot2 3.3 Movement trajectory data 3.4 Convex hull polygon 3.5 Export new objects 3.6 Animated plots for movement data 3.7 Retrieve animal observations using R client for APIs", " 3 Animal oceanographers 3.1 Import spatial data from CSV files One of the core components of R are data.frame objects. You can turn tabular text files, spreadsheets and databases into data.frame objects. Having spatial coordinates in your data.frame will allow you to easily turn it into a spatial object. In this example we will import a dataset of CTD (conductivity, temperature, depth) profiles from oceanographic sensors that were equipped on Souther Elephant Seals. This is a subset of the MEOP-CTD in-situ data collection. # Import data # Subset of Mirounga leonina for 2012 mirounga &lt;- read.csv(&quot;data/meop/miorunga.csv&quot;) class(mirounga) ## [1] &quot;data.frame&quot; head(mirounga) ## species ptt tag date lon lat ## 1 Southern ellie 113368 ct77-167-12 2012-03-17 10:40:00 110.5548 -66.4558 ## 2 Southern ellie 113368 ct77-167-12 2012-03-17 14:20:00 110.3725 -66.3939 ## 3 Southern ellie 113368 ct77-167-12 2012-03-17 23:20:00 110.4566 -66.3640 ## 4 Southern ellie 113368 ct77-167-12 2012-03-18 01:10:00 110.4468 -66.3704 ## 5 Southern ellie 113368 ct77-167-12 2012-03-18 10:30:00 110.4070 -66.3601 ## 6 Southern ellie 113368 ct77-167-12 2012-03-18 14:40:00 110.4506 -66.3885 ## scientific_name ## 1 Mirounga leonina ## 2 Mirounga leonina ## 3 Mirounga leonina ## 4 Mirounga leonina ## 5 Mirounga leonina ## 6 Mirounga leonina Transform the data.frame into a sp class object # load library library(rgdal) # Convert to spatial class coordinates(mirounga) &lt;- ~lon+lat # View spatial attributes proj4string(mirounga) # displays the coordinate reference system (CRS) ## [1] NA We need to set the CRS of the spatial layer # Use EPSG code proj4string(mirounga) &lt;- CRS(&quot;+init=epsg:4326&quot;) # Alternative using proj4 string # proj4string(mirounga) &lt;- CRS(&quot;+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0&quot;) Using EPSG codes can be more convenient that using larger strings. You can find more about EPSG codes in Spatial Reference We now make a quick exploration by plotting the data # Quick plot plot(mirounga) We may need to show some land map as reference # Import countries countries &lt;- readOGR(dsn = &quot;data/ne/ne_110m_admin_0_countries&quot;, layer = &quot;ne_110m_admin_0_countries&quot;) ## OGR data source with driver: ESRI Shapefile ## Source: &quot;C:\\Git\\spatial_data_analysis\\data\\ne\\ne_110m_admin_0_countries&quot;, layer: &quot;ne_110m_admin_0_countries&quot; ## with 177 features ## It has 94 fields ## Integer64 fields read as strings: POP_EST NE_ID plot(countries, col = &quot;grey80&quot;, border = &quot;grey80&quot;, axes = TRUE) plot(mirounga, pch = 20, add = TRUE) 3.2 Advanced maps with ggplot2 In this example we will use ggplot2 to display the CTD data. Due to the high density, we will bin data into regular cells to summarize the observations. Finally, we will also explore how to change the CRS of the plot into a polar projection. # load library library(ggplot2) library(viridis) # Import a new world dataset # country layer have some issues using orthographic projection world &lt;- map_data(&quot;world&quot;) # turn data from the maps package in to a data frame suitable for plotting with ggplot2 # Also turn back the CTD dataset into a data.frame mirounga_df &lt;- data.frame(mirounga) # Plot ggplot() + geom_bin2d(data = mirounga_df, aes(x = lon, y = lat), bins = 100) + geom_path(data = world, aes(x = long, y = lat, group = group), colour = &quot;#c0c0c0&quot;) + ylim(-90, -30) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + coord_map(&quot;ortho&quot;, orientation = c(-90, 0, 0)) + # orthographic projection from South Pole scale_fill_viridis(option = &quot;viridis&quot;, trans = &quot;log&quot;) + # log scale for bin count theme(panel.background = element_rect(&quot;white&quot;), # dark background axis.ticks = element_blank(), panel.grid = element_blank(), # remove panel grid axis.text = element_blank()) # remove x-axis value 3.3 Movement trajectory data # Select one tag track &lt;- mirounga[mirounga$tag == &quot;ct77-167-12&quot;,] plot(track, axes = TRUE) plot(countries, col = &quot;grey80&quot;, border = &quot;grey80&quot;, add=TRUE) 3.4 Convex hull polygon # Calculate convex hull polygon library(adehabitatHR) hull &lt;- mcp(track, percent = 100) plot(hull, col = &quot;lightblue&quot;) plot(track,add=TRUE) plot(countries, col = &quot;grey80&quot;, border = &quot;grey80&quot;, add=TRUE) 3.5 Export new objects Finally, we will export this new sp objects into a shapefile in order to be imported into a GIS software like QGIS # Export to Shapefile writeOGR(track, dsn = &quot;data/meop&quot;, layer = &quot;track_points&quot;, driver = &quot;ESRI Shapefile&quot;, overwrite_layer = TRUE) writeOGR(hull, dsn = &quot;data/meop&quot;, layer = &quot;track_hull&quot;, driver = &quot;ESRI Shapefile&quot;, overwrite_layer = TRUE) # Export to KML writeOGR(track, dsn = &quot;data/meop/track_points.kml&quot;, layer = &quot;track&quot;, driver = &quot;KML&quot;, overwrite_layer = TRUE) writeOGR(hull, dsn = &quot;data/meop/track_hull.kml&quot;, layer = &quot;hull&quot;, driver = &quot;ESRI Shapefile&quot;, overwrite_layer = TRUE) 3.6 Animated plots for movement data # Import libraries library(lubridate) # parse times library(move) # move object class and tools for trajectories library(moveVis) # animation plots First, we will convert the trajectory data into a move object # Back transform SpatialPointsDataFrame into a data.frame track &lt;- as.data.frame(track) # parse date time track$date &lt;- parse_date_time(track$date, &quot;Ymd HMS&quot;) # convert to move object mdata &lt;- move(x=track$lon, y=track$lat, time=track$date, data=track, proj=CRS(&quot;+proj=longlat +ellps=WGS84&quot;), animal=track$tag) Trajectories from animals or human can be recorded at irregular sampling intervals. To explore data using animations, we need to generated unique time frames. Therefore, we have to interpolate the trajectory at regular time intervals. # align move_data to a uniform time scale # For animation, unique frame times are needed m &lt;- align_move(mdata, res = 1, digit = 0, unit = &quot;days&quot;, spaceMethod = &quot;greatcircle&quot;) Next step is to create individuals frames for each time step # create spatial frames with a OpenStreetMap watercolour map frames &lt;- frames_spatial(m, # move object map_service = &quot;carto&quot;, map_type = &quot;voyager_no_labels&quot;, # base map path_size = 2, path_colours = c(&quot;orange&quot;), alpha = 0.5) %&gt;% # path add_labels(x = &quot;Longitude&quot;, y = &quot;Latitude&quot;) %&gt;% # add some customizations add_northarrow(colour = &quot;black&quot;, position = &quot;bottomright&quot;) %&gt;% add_scalebar(colour = &quot;black&quot;, position = &quot;bottomleft&quot;) %&gt;% add_timestamps(m, type = &quot;label&quot;) %&gt;% add_progress(size = 2) ## Processing movement data... ## Approximated animation duration: ˜ 9.12s at 25 fps for 228 frames ## Retrieving and compositing basemap imagery... ## Assigning raster maps to frames... ## Creating frames... We can preview one of the created frames frames[[100]] # preview one of the frames, e.g. the 100th frame Finally, we can generate an animation by combining all individual frames. This function takes a while… # animate frames # animate_frames(frames, out_file = &quot;img/animation.gif&quot;, overwrite = TRUE, display = FALSE) Animation in lonlat 3.6.1 Extra bonus We will combine our previous knowledge to transform data into a polar projection. And will use a custom base maps in raster format. # transform trajectory to the polar stereographic projection (EPSG:3031) mpol &lt;- spTransform(m, crs(&quot;+init=epsg:3031&quot;)) # import base map bmap &lt;- brick(&quot;data/ne/NE1_50M_SR_W/NE1_50M_SR_W.tif&quot;) # plot base map raster plot(bmap) # compose the 3 RGB bands of Tif file plotRGB(bmap) # crop basedmap to extent of track (plus 2 degrees) bmap &lt;- crop(bmap, extent(-180, 180, -90, -40)) # reproject raster to polar stereographic projection (EPSG:3031) bmap_pol &lt;- projectRaster(bmap, crs = crs(&quot;+init=epsg:3031&quot;)) # plot data plotRGB(bmap_pol, addfun = lines(mpol)) Prepare individual frames for animation. Note this time there are several differences in the code # create spatial frames with a OpenStreetMap watercolour map frames &lt;- frames_spatial(mpol, r_list = bmap_pol, r_times = m$time[1], ext = extent(bmap_pol), #custom base map path_size = 2, path_colours = c(&quot;orange&quot;), alpha = 0.5) %&gt;% add_timestamps(mpol, type = &quot;label&quot;) %&gt;% add_progress(size = 2) ## Processing movement data... ## Approximated animation duration: ˜ 9.12s at 25 fps for 228 frames ## Assigning raster maps to frames... ## Creating frames... frames[[100]] # preview one of the frames, e.g. the 100th frame This time, we will remove the axis labels # remove axis frames &lt;- add_gg(frames, gg = expr(theme(axis.ticks = element_blank(), axis.title = element_blank(), axis.text = element_blank()))) frames[[100]] # preview one of the frames, e.g. the 100th frame Finally, we can generate an animation by combining all individual frames. This function takes a while… # animate frames # animate_frames(frames, out_file = &quot;img/animation_polar.gif&quot;, overwrite = TRUE, display = FALSE) Animation in polar projection 3.7 Retrieve animal observations using R client for APIs Several public online databases offer the posibility to extract their information using an application programming interface (API). An API is a set of routines, protocols, and tools for building software applications. There are some R packages that allow the connection to those APIs in order to retrieve information. Here, we show the use of one client for the Ocean Biogeographic Information System that allow us to extract species occurrence records. # load library library(robis) # import data # records &lt;- occurrence(&quot;Physeter macrocephalus&quot;) # Scientific name of the sperm whale. You can replace it with your favourite one! "]
]
