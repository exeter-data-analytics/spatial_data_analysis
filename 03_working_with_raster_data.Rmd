---
title: "03_working_with_raster_data"
author: "Chris Yeomans"
date: "04/10/2019"
output: html_document
---

# Raster: Working with raster data

This chapter will introduce you to some of the key concepts surrounding the use
of raster spatial data in R. You will learn the basics of how to create, manipulate,
import and export raster data. 

## Setup
```{r, install, include = F, eval=F}
install.packages("raster")
install.packages("rgdal")
install.packages("elevatr")
install.packages("rgeos")
install.packages("leaflet")
install.packages("rgl")
```
```{r, libraries, message = F, results='hide', warning = FALSE}
library(raster)
library(rgdal)
library(elevatr)
library(rgeos)
library(leaflet)
library(RColorBrewer)
library(rgl)
```

## Importing and plotting raster data

Getting raster data in is easy and can be done using the following commands:

```{r, message = F}
r1 <- raster()
s1 <- stack()
```

The `raster` function is used for single layer files and the `stack` function for 
raster datasets with multiple layers, or for combining single layer rasters into 
a multilayer raster.

### Importing a raster layer

A single raster layer is easily imported. Here we load an example from the 
system repository:
```{r, layer}
r1 <- raster(system.file("external/test.grd", package="raster"))
```

### Importing a raster stack

Rasters can be stacked and this is particularly useful for RGB layers in a raster. 
For example, we can illustrate this using the R logo:
```{r, stack, message=F}
sRLogo <- stack(system.file("external/rlogo.grd", package="raster"))
nlayers(sRLogo)
```

There are three layers in `sRLogo` representing the red, green and blue 
channels (RGB). These can be plotted individually:

```{r, message = F, fig.cap = c("The R logo 1", "The R logo 2", "The R logo 3")}
image(sRLogo, y = 1)
image(sRLogo$green)
image(sRLogo[[3]])
```

Note that the initial code to call these layers can vary. The first uses 
the options within the `image` function, the second calls the name of the layer 
`green` and finally the last uses the index of the layer. These are useful to 
know as it may be appropriate to use different calls for different 
purposes - here it makes little difference.

These data may be more useful if plotted as an RGB plot. R isn't great at this 
but for a quick visualisation we can use `plotRGB`:

```{r, fig.cap="R Logo with a linear stretch (default)"}
plotRGB(sRLogo, stretch = "lin")
```

There are few tricks to ```plotRGB``` worth exploring such as changing the stretch:
```{r, fig.cap="R Logo with a histogram equalised stretch"}
plotRGB(sRLogo, stretch = "hist")
```

And changing the order of the bands - useful when RGB are not in the correct order:

### A random synthetic raster

Sometimes it can be useful to generate a random synthetic dataset. This could be 
for adding random noise to a dataset or for simple testing, or creating a 
reproducible example:

```{r, random raster, message = F}
rSynth <- raster()
set.seed(0)
values(rSynth) <- runif(ncell(rSynth), 0, 100)
```

The success of this can be checked in a number of ways:
```{r, eval=F}
hasValues(rSynth)
length(values(rSynth))
ncell(rSynth)
```

Similarly, a synthetic raster stack can be generated by simply manipulating the values:
```{r, stacks}
sSynth <- stack(rSynth, rSynth*2, sqrt(rSynth))
plot(sSynth[[2]])
plotRGB(sSynth, 1,2,3)
```

### Rasterising Vector Data

Given that raster data is generally more efficient to work with, and that sometimes
vector data is not suitable for a particular analysis, you may wish to rasterise
your vector data. This is easily achieved in R, although you must carefully consider
how your spatial data will be represented in its new form. 

#### Points

For this example, we will create a random set of points:

```{r, random points}
n <- 40
set.seed(123)
x <- runif(n) * 360 - 180
y <- runif(n) * 180 - 90
xy <- cbind(x, y)
```

And some accompanying random values:

```{r, random values}
z <- runif(n, 0.1, 10)
z2 <- runif(n, 0.1, 5)
z3 <- runif(n, 0.1, 3)
zzz <- cbind(z,z2,z3)
```

The `rasterize` function can then be utilised to convert from vector to raster format:

```{r, points1}
rPoints0 <- raster(ncols=36, nrows=18)
rPoints1 <- rasterize(xy, rPoints0)
rPoints2 <- rasterize(xy, rPoints0, field = z)
rPoints3 <- rasterize(xy, rPoints0, field = zzz) # Note the form of the object create (RasterBrick)
plot(rPoints3)
```

Similarly, `rasterize` can also be used on spatial objects, such as SpatialPointsDataFrames:
```{r, points2}
dfPoints <- data.frame(xy, name = zzz)
coordinates(dfPoints) <- ~x+y # Note the change in object type
rPoints4 <- rasterize(dfPoints, rPoints0, zzz)
plot(rPoints4)
```

#### Lines

For this example, we will create some lines:
```{r, lines}
cds1 <- rbind(c(-180,-20), c(-140,55), c(10, 0), c(-140,-60))
cds2 <- rbind(c(-10,0), c(140,60), c(160,0), c(140,-55))
cds3 <- rbind(c(-125,0), c(0,60), c(40,5), c(15,-45))

lines <- spLines(cds1, cds2, cds3)
rLines0 <- raster(ncols=90, nrows=45)
rLines1 <- rasterize(lines, rLines0)
plot(rLines1)
```

#### Polygons

For this example, we will create some polygons:
```{r, polygons}
p1 <- rbind(c(-180,-20), c(-140,55), c(10, 0), c(-140,-60), c(-180,-20))
hole <- rbind(c(-150,-20), c(-100,-10), c(-110,20), c(-150,-20))
p1 <- list(p1, hole)
p2 <- rbind(c(-10,0), c(140,60), c(160,0), c(140,-55), c(-10,0))
p3 <- rbind(c(-125,40), c(0,60), c(40,5), c(15,-45), c(-125,40))

pols <- spPolygons(p1, p2, p3)
rPols0 <- raster(ncol=90, nrow=45)
rPols1 <- rasterize(pols, rPols0)
rPols2 <- rasterize(pols, rPols0, fun="min")
rPols3 <- rasterize(pols, rPols0, fun="mean")
plot(rPols1)
plot(rPols2)
plot(rPols3)
plot(pols, add=T)
```

## Real examples

Moving on from creating, plotting and manipulating non-spatial or synthetic raster
data, we will now use some real world examples to further explore raster data in 
R. 

### Elevation data

Here we use a vector file to define our area of interest when requesting elevation
data from an external API:
```{r, read shp file}
cwl <- readOGR("data/ukdata/england_ct_2001.shp")
wgs84 = '+proj=longlat +datum=WGS84'
cwl_WGS84 <- spTransform(cwl, CRS(wgs84))
```

The elevation data is accessed using the `elevatr` package. more details can be found [here](https://cran.r-project.org/web/packages/elevatr/vignettes/introduction_to_elevatr.html)
```{r, get elev}
elev_cwl_WGS84 <- get_elev_raster(cwl_WGS84, z=9)
plot(elev_cwl_WGS84)
```

## Raster operations

The `raster` package provides a variety of functions to perform common GIS operations
on your raster data:

Firstly, there is `mask`:
```{r, mask}
mask_elev <- mask(elev_cwl_WGS84, cwl_WGS84)
plot(mask_elev)
```

And then there is `crop`:
```{r, crop}
e <- extent(cwl_WGS84)
crop_mask_elev <- crop(mask_elev, e)
plot(crop_mask_elev, main="mask")
```

This can be reprojected:
```{r, reproject}
elev_cwl_BNG <- projectRaster(crop_mask_elev, crs = crs(cwl))
plot(elev_cwl_BNG)
```

This current `elev_cwl_BNG` file is an odd spatial resolution so we want to make 
give it regular 100 m square cells. This can be done with `resample`:
```{r, resampling}
elev_cwl_BNG
tmpR <- raster(nrow=1271,ncol=1669)
crs(tmpR) <- crs(cwl)
extent(tmpR) <- c(81600,248500,-2600,124500)
elev_100m <- resample(elev_cwl_BNG, tmpR)
plot(elev_100m,main="100 m")
```

Let's remove the Isles of Scilly with the `extract` function.

Firstly, we need to find some coordinates that fall between the Isles of Scilly 
(westernmost data) and the mainland AND south of Lizard Point (southernmost mainland). 
Use the `locator` function to interact with the plot window. Click ``Finished'' 
in the top right corner when you are done to view the coordinates in console:
```{r, locator, eval=F, results='hide'}
locator() # find a location between IoS and mainland and south of Lizard Point
```

Now we can take those coordinates and round them to the nearest 100 m:
```{r, cropping IoS}
# For example you could try this... but give the locator() tool a go
e_crop <- c(129000, 248500, 1600, 124500) # xmin, xmax, ymin, ymax
# Now crop
crop_elev_100m <- crop(elev_100m, e_crop)
plot(crop_elev_100m, main="crop")
# Let's convert this back to WGS84
elev_100m_WGS84 <- projectRaster(crop_elev_100m, crs = crs(wgs84))
plot(elev_100m_WGS84, main="100 m WGS84")
```

Another operation called `aggregate` allows us to reduce the spatial resolution:
```{r, aggregate}
elev_1000m <- aggregate(crop_elev_100m,10,fun=mean,expand=TRUE, na.rm=TRUE)
plot(elev_1000m, main = "1000 m")
```

## Raster Manipulation

### Raster maths

Simple raster maths or 'map algebra' can be done as per the example below but it can 
get much more complicated. When using another raster to perform an operation in your 
raster math, both rasters must have the same extent and resolution:
```{r}
doubled <- elev_100m_WGS84*2
squared <- elev_100m_WGS84*elev_100m_WGS84
```

The `cellStats` function is useful for finding broad statistics about a layer 
e.g. sum, mean, min, max, sd, 'skew' and 'rms' of which the latter two must be 
supplied as a character value (with quotes):
```{r}
cellStats(elev_100m_WGS84, stat='mean')
```

### Terrain models

Quite often, much more information can be obtained from raster data, by looking at 
the relationship between a cell and it's neighbours. Topographical indices such as
slope and aspect can be obtained by using a single function with our elevation data:
```{r}
models <- terrain(elev_100m_WGS84, opt=c("slope", "aspect", "TPI", "TRI", 
                                         "roughness", "flowdir"), unit='degrees')
class(models)
models
plot(models)
```

### Hillshade

We can also make a hillshade raster and overlay the elevation data. We introduce 
a way of subsetting the raster stack/brick here using `subset` but you could 
also use `slope <- models$slope` or other means we introduced at the beginning 
of this section:
```{r}
slope <- subset(models, "slope")  # select slope
aspect <- subset(models, "aspect")  # select slope
hill <- hillShade(slope, aspect, 45, 270)
plot(hill, col = grey(0:100/100), legend = FALSE)
plot(elev_100m_WGS84, col = rainbow(25, alpha=0.35), add=TRUE)
```

## Visualisation

### Create a map

Maps can be quickly created using `leaflet` and basemaps from OpenStreetMap 
or tiles from MapBox imagery can be imported to enhance the map:
```{r}
pal <- colorNumeric(c("#FFFFCC", "#41B6C4", "#0C2C84"), domain=c(0,500, na.rm=T),
                    na.color = "transparent", reverse = T)
leaflet() %>%
  addTiles() %>%  # OpenStreetMap base map
  addRasterImage(elev_100m_WGS84, colors = pal, opacity = 0.8) %>%
  addLegend(pal = pal, values = c(0, 500),
            title = "Cornwall Elevation")
```
The `leaflet` package is highly versatile and can do a lot more. 
You can explore more [here](https://rstudio.github.io/leaflet/). 


### Visualize in 3D

We can also make an interative 3D plot of a RasterLayer. You can modifiy several parameters like the color palette or the elevation scale relative to x and y.

```{r message = FALSE, warning = FALSE}
library(rgl)
library(rasterVis)
```

```{r}
plot3D(elev_100m_WGS84, zfac = 1, col=terrain.colors, rev=FALSE)  # plot 3d with rgl
```

```{r echo=FALSE}
rglwidget()
```


## Saving raster data

There are a number of ways to save your data to files. First let's create an 
output folder if you don't already have one:
```{r}
dir.create("output")
```

Now we can write our rasters as layers, stacks or write layers from stacks, using
the `writeRaster` function:
```{r}
# A raster layer
writeRaster(slope, filename="output/slope.tif", format="GTiff", overwrite=TRUE)
# A layer from a raster stack/brick
writeRaster(models[[1]], filename="output/tri", format="GTiff", overwrite=TRUE)
# A whole stack/brick
writeRaster(models, filename="output/models", format="GTiff", overwrite=TRUE)
# A whole raster stack/brick by layer
writeRaster(models, filename=paste("output/", names(models), sep = ""), format="GTiff", bylayer=T, overwrite=TRUE)
```

Or you can write it to a KML file with a set colour palette:
```{r}
myPal <- colorRampPalette(brewer.pal(9, 'Blues'), alpha=TRUE)  # palette
KML(elev_100m_WGS84, "output/elev_100m_WGS84.kml", col = myPal(100), overwrite = TRUE)
```
