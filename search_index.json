[
["index.html", "Introduction to Spatial Analysis in R 1 Introduction 1.1 Set up your working environment", " Introduction to Spatial Analysis in R D March, J Duffy &amp; Chris Yeomans 04/10/2019 1 Introduction In this workshop we are going to work with vector data (points, lines and polygons) and raster data. R has an extraordinary potential to handle this data and perform complex spatial operations like other Geographic Information Systems (GIS) software. We will explore the capacities of R to handle and manipulate vector data through two worked examples: Hello, world! Animal oceanographers We will also play with raster data with a further two examples: Introduction to raster data Working with real world data Accompanying slides can be downloaded from here 1.1 Set up your working environment Create a new project within Rstudio. If you are unsure, instructions on how to do this can be found here. Download the Data. Unzip and store its contents in a folder named data within your new project. Now create the following folders within your project - output &amp; img. This can be done from within R as follows: dir.create(&quot;output&quot;) dir.create(&quot;img&quot;) Run the following code to install all required packages: install.packages(c(&quot;rgdal&quot;, &quot;raster&quot;, &quot;viridis&quot;, &quot;leaflet&quot;, &quot;ggplot2&quot;, &quot;mapproj&quot;, &quot;robis&quot;, &quot;gifski&quot;, &quot;elevatr&quot;, &quot;move&quot;, &quot;moveVis&quot;, &quot;dplyr&quot;, &quot;lubridate&quot;, &quot;rgeos&quot;, &quot;adehabitatHR&quot;, &quot;RColorBrewer&quot;, &quot;rasterVis&quot;, &quot;rgl&quot;)) Once your working environment is set up, you can copy/paste the lines of code from this website into R script(s) to run. "],
["vector-hello-world.html", "2 Vector: Hello, world! 2.1 Importing vector data 2.2 Coordinate Reference Systems (CRS) 2.3 Geographic subset 2.4 Spatial overlap 2.5 Interactive maps", " 2 Vector: Hello, world! This chapter will introduce you to some of the key concepts surrounding the use of vector spatial data in R. You will learn the basics of how to import and manipulate vector data. 2.1 Importing vector data 2.1.1 Spatial data formats The Geospatial Data Abstraction Library (GDAL) is a translator library for raster and vector geospatial data formats. It underpins most GIS software (both proprietary and open-source). We will start by loading the R package of this library and check all the vector data formats that can be imported into R. library(rgdal) vector_formats &lt;- ogrDrivers() head(vector_formats) ## name long_name write copy isVector ## 1 AeronavFAA Aeronav FAA FALSE FALSE TRUE ## 2 AmigoCloud AmigoCloud TRUE FALSE TRUE ## 3 ARCGEN Arc/Info Generate FALSE FALSE TRUE ## 4 AVCBin Arc/Info Binary Coverage FALSE FALSE TRUE ## 5 AVCE00 Arc/Info E00 (ASCII) Coverage FALSE FALSE TRUE ## 6 BNA Atlas BNA TRUE FALSE TRUE Here, vector_formats is a data frame containing names and information of various formats supported by GDAL. You can explore vector_formats. How many different formats are available? Are you familiar with any of them? 2.1.2 Import vector data: Shapefile Shapefile is a popular format used in GIS. Typically shapefiles consist of four (and sometimes more) files. These have the following extensions: .shp, .shx, .dbf, and .prj. You are likely to encounter shapefiles a lot, especially if working with 3rd party data (e.g. point location data from an NGO). We will import a polygon layer of the world countries extracted from Natural Earth Data. This data should be available in your data folder: countries &lt;- readOGR(dsn = &quot;data/ne/ne_110m_admin_0_countries&quot;, layer = &quot;ne_110m_admin_0_countries&quot;) ## OGR data source with driver: ESRI Shapefile ## Source: &quot;C:\\Git\\spatial_data_analysis\\data\\ne\\ne_110m_admin_0_countries&quot;, layer: &quot;ne_110m_admin_0_countries&quot; ## with 177 features ## It has 94 fields ## Integer64 fields read as strings: POP_EST NE_ID OGR is the vector part of the GDAL library. For future reference, any functions with OGR in its name will mostly likely be used to read, write or manipulate vector data. It is also worth noting that the syntax used within readOGR can vary depending on the vector format being read. If you have trouble reading in other types vector data, you will likely be able to find examples online. Lets make our first plot using base R graphics: plot(countries, main = &quot;World countries&quot;) We can check the class and spatial attributes of this layer: class(countries) # sp class ## [1] &quot;SpatialPolygonsDataFrame&quot; ## attr(,&quot;package&quot;) ## [1] &quot;sp&quot; We can see that this data is a SpatialPolygonsDataFrame. Within this object, there are multiple pieces of information stored in slots. Slots can be accesed with the @ symbol. Lets see what is contained within the slots of countries: # the attribute table head(countries@data) # the coordinates of each point making up each of the polygons head(countries@polygons) # the bounding box / extent of the data countries@bbox 2.1.3 Import vector data: Geopackage Despite the popularity of Shapefiles, we (well, mainly James) strongly encourage you to adopt the Geopackage format. One huge benefit of the .gpkg file type is that all data is stored in a single file, as opposed to the 4+ found in shapefiles. We will import a modified version of the “Populated places of the world” dataset, also from from Natural Earth Data: # import geopackage places &lt;- readOGR(&quot;data/ne/ne_110m_populated_places_simple.gpkg&quot;) ## OGR data source with driver: GPKG ## Source: &quot;C:\\Git\\spatial_data_analysis\\data\\ne\\ne_110m_populated_places_simple.gpkg&quot;, layer: &quot;places&quot; ## with 243 features ## It has 38 fields # view spatial attributes class(places) ## [1] &quot;SpatialPointsDataFrame&quot; ## attr(,&quot;package&quot;) ## [1] &quot;sp&quot; plot(places, main = &quot;Populated places&quot;) As you can see, the class of this data is a SpatialPointsDataFrame. It has similar properties to the SpatialPolygonsDataFrame seen with the countries object, except, that each feature is represented by a single point, rather than group of points making a polygon. The plot of points is not very informative on its own. Let’s combine with the world map: plot(countries, col = &quot;grey80&quot;, border = &quot;grey80&quot;) plot(places, pch = 20, col = &quot;darkblue&quot;, add = TRUE) This plot demonstrates the key role that layering plays in GIS and spatial data visualisation. Some maps will contain many layers of information stacked on top of one another, each representing a different feature or set of features. 2.2 Coordinate Reference Systems (CRS) You can check the CRS of your spatial object. This is stored as a character string: proj4string(countries) # displays the coordinate reference system (CRS) ## [1] &quot;+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0&quot; Sometimes, you may wish to reproject your data, either for visualisation or analysis purposes. In this case, we transform to the Mollweide projection. This is an accurate single global projection that preserves geographic area. You can see an example of application in March et al. 2019: countries_moll &lt;- spTransform(countries, CRS(&quot;+proj=moll +ellps=WGS84&quot;)) plot(countries_moll, col = &quot;grey80&quot;, main = &quot;World countries&quot;) 2.3 Geographic subset Subsetting data is a useful way to select data only relevant to you. This can be done spatially, i.e. selecting data that falls within an area of interest, or by attributes. The latter utilises the attirubte table to filter the data, returning spatial objects that match the desired profile. 2.3.1 Geographic subset by setting a bounding box First, create a bounding area for subsetting the data: library(raster) # Set min and maximum coordinates (lon/lat) xmin &lt;- -15 xmax &lt;- 46 ymin &lt;- 28 ymax &lt;- 60 # Create an extent object e &lt;- extent(xmin, xmax, ymin, ymax) class(e) ## [1] &quot;Extent&quot; ## attr(,&quot;package&quot;) ## [1] &quot;raster&quot; Then, you can use the extent object to subset the world map using the crop function (from the raster package, but also works on vector data): countries_subset &lt;- crop(countries, e) plot(countries_subset) Task Make a plot of South America Tip: you can use QGIS or Google Earth to search for coordinates to use in your extent object. 2.3.2 Geographic subset by data attributes As we discovered earlier, the linked attribute table is stored in the data slot. In this case, the table contains specific information for each country. You can explore convert the data object from countries into a data.frame and then explore the attribute data more easily: df &lt;- data.frame(countries@data) head(df) List of continents: unique(countries$CONTINENT) ## [1] Oceania Africa North America ## [4] Asia South America Europe ## [7] Seven seas (open ocean) Antarctica ## 8 Levels: Africa Antarctica Asia Europe North America ... South America Subset countries from South America: south_america &lt;- countries[countries$CONTINENT == &quot;South America&quot;,] plot(south_america, col = &quot;lightgreen&quot;, border = &quot;darkgreen&quot;, lwd=3, main = &quot;South America&quot;) extent(south_america) # you can also get your extent ## class : Extent ## xmin : -81.41094 ## xmax : -34.72999 ## ymin : -55.61183 ## ymax : 12.4373 2.4 Spatial overlap Determining the overlap between spatial layers in order to extract information from one to another is one of the most common tasks in GIS. Here, we want to plot the populated places, but only in Africa. However, there is no information about the continent in the places layer We will use a spatial overlay to extract information from the countries layer using the over function: ov &lt;- over(places, countries) class(ov) ## [1] &quot;data.frame&quot; This operation returns a data.frame containing the same number of features as places, but with the spatially matching attributes from countries. We then can append the continent information to the attribute table of the places point layer: places$CONTINENT &lt;- ov$CONTINENT head(places) Note that there are features with NA in the CONTINENT attribute. This is due to a spatial missmatch between layers in terms of resolution, more specifically because of the coarse resolution of the countries layer. There are several alternatives: 1) use a high-res countries map, 2) calculate the nearest polygon. places_africa &lt;- places[which(places$CONTINENT == &quot;Africa&quot;),] plot(countries, col = &quot;grey80&quot;, border = &quot;grey80&quot;) plot(places_africa, pch = 20, col = &quot;darkblue&quot;, add = TRUE) 2.5 Interactive maps Spatial datasets can sometimes require an interactive visualization of the data. In R, we can use the leaflet library to generate a dynamic viewer: # import leaflet package library(leaflet) # create leaftet map map &lt;- leaflet(data = places) %&gt;% addProviderTiles(&quot;Esri.OceanBasemap&quot;) %&gt;% # Base map addMarkers(popup = ~name) # plot leaflet map map You can customize your map using different basemaps, add more spatial layers and much more. You can check the official package website for many examples. "],
["vector-animal-oceanographers.html", "3 Vector: Animal oceanographers 3.1 Import spatial data from .csv files 3.2 Advanced maps with ggplot2 3.3 Movement trajectory data 3.4 Convex hull polygon 3.5 Export new objects 3.6 Animated plots for movement data 3.7 Retrieve animal observations using R client for APIs", " 3 Vector: Animal oceanographers 3.1 Import spatial data from .csv files One of the core components of R are data.frame objects. You can turn tabular text files, spreadsheets and databases into data.frame objects. Having spatial coordinates in your data.frame will allow you to easily turn it into a spatial object. In this example we will import a dataset of CTD (conductivity, temperature, depth) profiles from oceanographic sensors that were equipped on Southern Elephant Seals. This is a subset of the MEOP-CTD in-situ data collection. # subset of Mirounga leonina for 2012 mirounga &lt;- read.csv(&quot;data/meop/miorunga.csv&quot;) class(mirounga) ## [1] &quot;data.frame&quot; head(mirounga) ## species ptt tag date lon lat ## 1 Southern ellie 113368 ct77-167-12 2012-03-17 10:40:00 110.5548 -66.4558 ## 2 Southern ellie 113368 ct77-167-12 2012-03-17 14:20:00 110.3725 -66.3939 ## 3 Southern ellie 113368 ct77-167-12 2012-03-17 23:20:00 110.4566 -66.3640 ## 4 Southern ellie 113368 ct77-167-12 2012-03-18 01:10:00 110.4468 -66.3704 ## 5 Southern ellie 113368 ct77-167-12 2012-03-18 10:30:00 110.4070 -66.3601 ## 6 Southern ellie 113368 ct77-167-12 2012-03-18 14:40:00 110.4506 -66.3885 ## scientific_name ## 1 Mirounga leonina ## 2 Mirounga leonina ## 3 Mirounga leonina ## 4 Mirounga leonina ## 5 Mirounga leonina ## 6 Mirounga leonina Transform the data.frame into a sp class object: library(rgdal) coordinates(mirounga) &lt;- ~lon+lat proj4string(mirounga) # displays the coordinate reference system (CRS) ## [1] NA We need to set the CRS of the spatial layer: # use EPSG code proj4string(mirounga) &lt;- CRS(&quot;+init=epsg:4326&quot;) # alternative using proj4 string # proj4string(mirounga) &lt;- CRS(&quot;+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0&quot;) Using EPSG codes can be more convenient that using larger strings. You can find more about EPSG codes at the Spatial Reference website. We can now plot the data to see how it looks: plot(mirounga) As with the previous practical, adding some layers to give context to the data would be ideal: countries &lt;- readOGR(dsn = &quot;data/ne/ne_110m_admin_0_countries&quot;, layer = &quot;ne_110m_admin_0_countries&quot;) ## OGR data source with driver: ESRI Shapefile ## Source: &quot;C:\\Git\\spatial_data_analysis\\data\\ne\\ne_110m_admin_0_countries&quot;, layer: &quot;ne_110m_admin_0_countries&quot; ## with 177 features ## It has 94 fields ## Integer64 fields read as strings: POP_EST NE_ID plot(countries, col = &quot;grey80&quot;, border = &quot;grey80&quot;, axes = TRUE) plot(mirounga, pch = 20, add = TRUE) 3.2 Advanced maps with ggplot2 In this example we will use ggplot2 to display the CTD data. Due to the high density, we will bin data into regular cells to summarize the observations. Finally, we will also explore how to change the CRS of the plot into a polar projection: library(ggplot2) library(viridis) # country layer have some issues using orthographic projection world &lt;- map_data(&quot;world&quot;) # turn data from the maps package in to a data frame suitable for plotting with ggplot2 # also turn back the CTD dataset into a data.frame mirounga_df &lt;- data.frame(mirounga) ggplot() + geom_bin2d(data = mirounga_df, aes(x = lon, y = lat), bins = 100) + geom_path(data = world, aes(x = long, y = lat, group = group), colour = &quot;#c0c0c0&quot;) + ylim(-90, -30) + xlab(&quot;&quot;) + ylab(&quot;&quot;) + coord_map(&quot;ortho&quot;, orientation = c(-90, 0, 0)) + # orthographic projection from South Pole scale_fill_viridis(option = &quot;viridis&quot;, trans = &quot;log&quot;) + # log scale for bin count theme(panel.background = element_rect(&quot;white&quot;), # dark background axis.ticks = element_blank(), panel.grid = element_blank(), # remove panel grid axis.text = element_blank()) # remove x-axis value 3.3 Movement trajectory data Trajectories represent the mobility of objects, such as people, vehicle or animals. Trajectories contain temporally sequenced location and time values (x, y, t) recorded from different devices (e.g. GPS, video-monitoring). In the following example, we will subset the MEOP-CTD dataset by selecting the trajectory of a single southern elephant seal (i.e., tag ct77-167-12). # Select one tag track &lt;- mirounga[mirounga$tag == &quot;ct77-167-12&quot;,] plot(track, axes = TRUE) plot(countries, col = &quot;grey80&quot;, border = &quot;grey80&quot;, add=TRUE) 3.4 Convex hull polygon Creating a convex hull around a set of points is another common GIS operation. This essentially creates the smallest polygon possible that can contain a given set of points. Variations in the parameters determining the characteristics of the polygon can also be applied, but for this example we will use the default settings. In R, this can be created with one line of code, utilising the mcp function: library(adehabitatHR) hull &lt;- mcp(track, percent = 100) plot(hull, col = &quot;lightblue&quot;) plot(track,add=TRUE) plot(countries, col = &quot;grey80&quot;, border = &quot;grey80&quot;, add=TRUE) 3.5 Export new objects Finally, we can export this new sp object into a shapefile, geopackage or KML in order to be imported into a GIS software like QGIS: # export to shapefile writeOGR(track, dsn = &quot;output&quot;, layer = &quot;track_points&quot;, driver = &quot;ESRI Shapefile&quot;, overwrite_layer = TRUE) writeOGR(hull, dsn = &quot;output&quot;, layer = &quot;track_hull&quot;, driver = &quot;ESRI Shapefile&quot;, overwrite_layer = TRUE) # export to geopackage writeOGR(track, dsn = &quot;output/track_points.gpkg&quot;, layer = &quot;track_points&quot;, driver = &quot;GPKG&quot;, overwrite_layer = TRUE) writeOGR(hull, dsn = &quot;output/track_hull.gpkg&quot;, layer = &quot;track_hull&quot;, driver = &quot;GPKG&quot;, overwrite_layer = TRUE) # export to KML writeOGR(track, dsn = &quot;output/track_points.kml&quot;, layer = &quot;track&quot;, driver = &quot;KML&quot;, overwrite_layer = TRUE) writeOGR(hull, dsn = &quot;output/track_hull.kml&quot;, layer = &quot;hull&quot;, driver = &quot;KML&quot;, overwrite_layer = TRUE) 3.6 Animated plots for movement data library(lubridate) # parse times library(move) # move object class and tools for trajectories library(moveVis) # animation plots First, we will convert the trajectory data into a move object: # back transform SpatialPointsDataFrame into a data.frame track &lt;- as.data.frame(track) # parse date time track$date &lt;- parse_date_time(track$date, &quot;Ymd HMS&quot;) # convert to move object mdata &lt;- move(x=track$lon, y=track$lat, time=track$date, data=track, proj=CRS(&quot;+proj=longlat +ellps=WGS84&quot;), animal=track$tag) Trajectories from animals or humans can be recorded at irregular sampling intervals. To explore data using animations, we need to generate unique time frames. Therefore, we have to interpolate the trajectory at regular time intervals: # align move_data to a uniform time scale # for animation, unique frame times are needed m &lt;- align_move(mdata, res = 1, digit = 0, unit = &quot;days&quot;, spaceMethod = &quot;greatcircle&quot;) The next step is to create individual frames for each time step: # create spatial frames with an OpenStreetMap watercolour map frames &lt;- frames_spatial(m, # move object map_service = &quot;carto&quot;, map_type = &quot;voyager_no_labels&quot;, # base map path_size = 2, path_colours = c(&quot;orange&quot;), alpha = 0.5) %&gt;% # path add_labels(x = &quot;Longitude&quot;, y = &quot;Latitude&quot;) %&gt;% # add some customizations add_northarrow(colour = &quot;black&quot;, position = &quot;bottomright&quot;) %&gt;% add_scalebar(colour = &quot;black&quot;, position = &quot;bottomleft&quot;) %&gt;% add_timestamps(m, type = &quot;label&quot;) %&gt;% add_progress(size = 2) ## Processing movement data... ## Approximated animation duration: ˜ 9.12s at 25 fps for 228 frames ## Retrieving and compositing basemap imagery... ## Assigning raster maps to frames... ## Creating frames... We can preview one of the frames: frames[[100]] Finally, we can generate an animation by combining all individual frames. This function takes a while… animate_frames(frames, out_file = &quot;img/animation.gif&quot;, overwrite = TRUE, display = FALSE) Animation in lonlat 3.6.1 Extra bonus material We will use a custom base map in raster format. We will explain more information about raster in the following module of the workshop. # import base map bmap &lt;- brick(&quot;data/ne/NE1_50M_SR_W/NE1_50M_SR_W.tif&quot;) # plot base map raster plot(bmap) # compose the 3 RGB bands of Tif file plotRGB(bmap) Now, we will transform both the track and the base map into a polar projection # transform trajectory to the polar stereographic projection (EPSG:3031) mpol &lt;- spTransform(m, crs(&quot;+init=epsg:3031&quot;)) # crop basedmap to cover the southern ocean (between 90S and 40S latitude) bmap &lt;- crop(bmap, extent(-180, 180, -90, -40)) # reproject raster to polar stereographic projection (EPSG:3031) bmap_pol &lt;- projectRaster(bmap, crs = crs(&quot;+init=epsg:3031&quot;)) # plot data plotRGB(bmap_pol, addfun = lines(mpol)) Prepare individual frames for animation. Note this time there are several differences in the code: # create spatial frames with a custom basemap frames &lt;- frames_spatial(mpol, r_list = bmap_pol, r_times = m$time[1], ext = extent(bmap_pol), #custom base map path_size = 2, path_colours = c(&quot;orange&quot;), alpha = 0.5) %&gt;% add_timestamps(mpol, type = &quot;label&quot;) %&gt;% add_progress(size = 2) ## Processing movement data... ## Approximated animation duration: ˜ 9.12s at 25 fps for 228 frames ## Assigning raster maps to frames... ## Creating frames... frames[[100]] # preview one of the frames, e.g. the 100th frame This time, we will remove the axis labels: # remove axis frames &lt;- add_gg(frames, gg = expr(theme(axis.ticks = element_blank(), axis.title = element_blank(), axis.text = element_blank()))) frames[[100]] # preview one of the frames, e.g. the 100th frame Finally, we can generate an animation by combining all individual frames. This function takes a while… # animate frames animate_frames(frames, out_file = &quot;img/animation_polar.gif&quot;, overwrite = TRUE) Animation in polar projection 3.7 Retrieve animal observations using R client for APIs Several public online databases offer the posibility to extract their information using an application programming interface (API). An API is a set of routines, protocols, and tools for building software applications. There are some R packages that allow the connection to those APIs in order to retrieve information. Here, we show the use of one client for the Ocean Biogeographic Information System that allow us to extract species occurrence records: library(robis) records &lt;- occurrence(&quot;Physeter macrocephalus&quot;) # Scientific name of the sperm whale. You can replace it with your favourite one! "],
["raster-working-with-raster-data.html", "4 Raster: Working with raster data 4.1 Setup 4.2 Importing and plotting raster data 4.3 Real examples 4.4 Raster operations 4.5 Raster Manipulation 4.6 Visualisation 4.7 Saving raster data", " 4 Raster: Working with raster data This chapter will introduce you to some of the key concepts surrounding the use of raster spatial data in R. You will learn the basics of how to create, manipulate, import and export raster data. 4.1 Setup library(raster) library(rgdal) library(elevatr) library(rgeos) library(leaflet) library(RColorBrewer) library(rgl) 4.2 Importing and plotting raster data Getting raster data in is easy and can be done using the following commands: r1 &lt;- raster() s1 &lt;- stack() The raster function is used for single layer files and the stack function for raster datasets with multiple layers, or for combining single layer rasters into a multilayer raster. 4.2.1 Importing a raster layer A single raster layer is easily imported. Here we load an example from the system repository: r1 &lt;- raster(system.file(&quot;external/test.grd&quot;, package=&quot;raster&quot;)) 4.2.2 Importing a raster stack Rasters can be stacked and this is particularly useful for RGB layers in a raster. For example, we can illustrate this using the R logo: sRLogo &lt;- stack(system.file(&quot;external/rlogo.grd&quot;, package=&quot;raster&quot;)) nlayers(sRLogo) ## [1] 3 There are three layers in sRLogo representing the red, green and blue channels (RGB). These can be plotted individually: image(sRLogo, y = 1) Figure 4.1: The R logo 1 image(sRLogo$green) Figure 4.2: The R logo 2 image(sRLogo[[3]]) Figure 4.3: The R logo 3 Note that the initial code to call these layers can vary. The first uses the options within the image function, the second calls the name of the layer green and finally the last uses the index of the layer. These are useful to know as it may be appropriate to use different calls for different purposes - here it makes little difference. These data may be more useful if plotted as an RGB plot. R isn’t great at this but for a quick visualisation we can use plotRGB: plotRGB(sRLogo, stretch = &quot;lin&quot;) Figure 4.4: R Logo with a linear stretch (default) There are few tricks to plotRGB worth exploring such as changing the stretch: plotRGB(sRLogo, stretch = &quot;hist&quot;) Figure 4.5: R Logo with a histogram equalised stretch And changing the order of the bands - useful when RGB are not in the correct order: plotRGB(sRLogo, r = 3, g = 2, b = 1, stretch = &quot;lin&quot;) Figure 4.6: R Logo with different order of bands 4.2.3 A random synthetic raster Sometimes it can be useful to generate a random synthetic dataset. This could be for adding random noise to a dataset or for simple testing, or creating a reproducible example: rSynth &lt;- raster() set.seed(0) values(rSynth) &lt;- runif(ncell(rSynth), 0, 100) The success of this can be checked in a number of ways: hasValues(rSynth) length(values(rSynth)) ncell(rSynth) Similarly, a synthetic raster stack can be generated by simply manipulating the values: sSynth &lt;- stack(rSynth, rSynth*2, sqrt(rSynth)) plot(sSynth[[2]]) plotRGB(sSynth, 1,2,3) 4.2.4 Rasterising Vector Data Given that raster data is generally more efficient to work with, and that sometimes vector data is not suitable for a particular analysis, you may wish to rasterise your vector data. This is easily achieved in R, although you must carefully consider how your spatial data will be represented in its new form. 4.2.4.1 Points For this example, we will create a random set of points: n &lt;- 40 set.seed(123) x &lt;- runif(n) * 360 - 180 y &lt;- runif(n) * 180 - 90 xy &lt;- cbind(x, y) And some accompanying random values: z &lt;- runif(n, 0.1, 10) z2 &lt;- runif(n, 0.1, 5) z3 &lt;- runif(n, 0.1, 3) zzz &lt;- cbind(z,z2,z3) The rasterize function can then be utilised to convert from vector to raster format: rPoints0 &lt;- raster(ncols=36, nrows=18) rPoints1 &lt;- rasterize(xy, rPoints0) rPoints2 &lt;- rasterize(xy, rPoints0, field = z) rPoints3 &lt;- rasterize(xy, rPoints0, field = zzz) # Note the form of the object create (RasterBrick) plot(rPoints3) Similarly, rasterize can also be used on spatial objects, such as SpatialPointsDataFrames: dfPoints &lt;- data.frame(xy, name = zzz) coordinates(dfPoints) &lt;- ~x+y # Note the change in object type rPoints4 &lt;- rasterize(dfPoints, rPoints0, zzz) plot(rPoints4) 4.2.4.2 Lines For this example, we will create some lines: cds1 &lt;- rbind(c(-180,-20), c(-140,55), c(10, 0), c(-140,-60)) cds2 &lt;- rbind(c(-10,0), c(140,60), c(160,0), c(140,-55)) cds3 &lt;- rbind(c(-125,0), c(0,60), c(40,5), c(15,-45)) lines &lt;- spLines(cds1, cds2, cds3) rLines0 &lt;- raster(ncols=90, nrows=45) rLines1 &lt;- rasterize(lines, rLines0) plot(rLines1) 4.2.4.3 Polygons For this example, we will create some polygons: p1 &lt;- rbind(c(-180,-20), c(-140,55), c(10, 0), c(-140,-60), c(-180,-20)) hole &lt;- rbind(c(-150,-20), c(-100,-10), c(-110,20), c(-150,-20)) p1 &lt;- list(p1, hole) p2 &lt;- rbind(c(-10,0), c(140,60), c(160,0), c(140,-55), c(-10,0)) p3 &lt;- rbind(c(-125,40), c(0,60), c(40,5), c(15,-45), c(-125,40)) pols &lt;- spPolygons(p1, p2, p3) rPols0 &lt;- raster(ncol=90, nrow=45) rPols1 &lt;- rasterize(pols, rPols0) rPols2 &lt;- rasterize(pols, rPols0, fun=&quot;min&quot;) rPols3 &lt;- rasterize(pols, rPols0, fun=&quot;mean&quot;) plot(rPols1) plot(rPols2) plot(rPols3) plot(pols, add=T) 4.3 Real examples Moving on from creating, plotting and manipulating non-spatial or synthetic raster data, we will now use some real world examples to further explore raster data in R. 4.3.1 Elevation data Here we use a vector file to define our area of interest when requesting elevation data from an external API: cwl &lt;- readOGR(&quot;data/ukdata/england_ct_2001.shp&quot;) ## OGR data source with driver: ESRI Shapefile ## Source: &quot;C:\\Git\\spatial_data_analysis\\data\\ukdata\\england_ct_2001.shp&quot;, layer: &quot;england_ct_2001&quot; ## with 18 features ## It has 2 fields wgs84 = &#39;+proj=longlat +datum=WGS84&#39; cwl_WGS84 &lt;- spTransform(cwl, CRS(wgs84)) The elevation data is accessed using the elevatr package. more details can be found here elev_cwl_WGS84 &lt;- get_elev_raster(cwl_WGS84, z=9) ## Merging DEMs ## Reprojecting DEM to original projection ## Note: Elevation units are in meters. ## Note: The coordinate reference system is: ## +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 plot(elev_cwl_WGS84) 4.4 Raster operations The raster package provides a variety of functions to perform common GIS operations on your raster data: Firstly, there is mask: mask_elev &lt;- mask(elev_cwl_WGS84, cwl_WGS84) plot(mask_elev) And then there is crop: e &lt;- extent(cwl_WGS84) crop_mask_elev &lt;- crop(mask_elev, e) plot(crop_mask_elev, main=&quot;mask&quot;) This can be reprojected: elev_cwl_BNG &lt;- projectRaster(crop_mask_elev, crs = crs(cwl)) plot(elev_cwl_BNG) This current elev_cwl_BNG file is an odd spatial resolution so we want to make give it regular 100 m square cells. This can be done with resample: elev_cwl_BNG ## class : RasterLayer ## dimensions : 1303, 1714, 2233342 (nrow, ncol, ncell) ## resolution : 97.3, 97.5 (x, y) ## extent : 81662.17, 248434.4, -2593.72, 124448.8 (xmin, xmax, ymin, ymax) ## crs : +proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +datum=OSGB36 +units=m +no_defs +ellps=airy +towgs84=446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894 ## source : memory ## names : layer ## values : -371.462, 819.7913 (min, max) tmpR &lt;- raster(nrow=1271,ncol=1669) crs(tmpR) &lt;- crs(cwl) extent(tmpR) &lt;- c(81600,248500,-2600,124500) elev_100m &lt;- resample(elev_cwl_BNG, tmpR) plot(elev_100m,main=&quot;100 m&quot;) Let’s remove the Isles of Scilly with the extract function. Firstly, we need to find some coordinates that fall between the Isles of Scilly (westernmost data) and the mainland AND south of Lizard Point (southernmost mainland). Use the locator function to interact with the plot window. Click ``Finished’’ in the top right corner when you are done to view the coordinates in console: locator() # find a location between IoS and mainland and south of Lizard Point Now we can take those coordinates and round them to the nearest 100 m: # For example you could try this... but give the locator() tool a go e_crop &lt;- c(129000, 248500, 1600, 124500) # xmin, xmax, ymin, ymax # Now crop crop_elev_100m &lt;- crop(elev_100m, e_crop) plot(crop_elev_100m, main=&quot;crop&quot;) # Let&#39;s convert this back to WGS84 elev_100m_WGS84 &lt;- projectRaster(crop_elev_100m, crs = crs(wgs84)) plot(elev_100m_WGS84, main=&quot;100 m WGS84&quot;) Another operation called aggregate allows us to reduce the spatial resolution: elev_1000m &lt;- aggregate(crop_elev_100m,10,fun=mean,expand=TRUE, na.rm=TRUE) plot(elev_1000m, main = &quot;1000 m&quot;) 4.5 Raster Manipulation 4.5.1 Raster maths Simple raster maths or ‘map algebra’ can be done as per the example below but it can get much more complicated. When using another raster to perform an operation in your raster math, both rasters must have the same extent and resolution: doubled &lt;- elev_100m_WGS84*2 squared &lt;- elev_100m_WGS84*elev_100m_WGS84 The cellStats function is useful for finding broad statistics about a layer e.g. sum, mean, min, max, sd, ‘skew’ and ‘rms’ of which the latter two must be supplied as a character value (with quotes): cellStats(elev_100m_WGS84, stat=&#39;mean&#39;) ## [1] 108.5968 4.5.2 Terrain models Quite often, much more information can be obtained from raster data, by looking at the relationship between a cell and it’s neighbours. Topographical indices such as slope and aspect can be obtained by using a single function with our elevation data: models &lt;- terrain(elev_100m_WGS84, opt=c(&quot;slope&quot;, &quot;aspect&quot;, &quot;TPI&quot;, &quot;TRI&quot;, &quot;roughness&quot;, &quot;flowdir&quot;), unit=&#39;degrees&#39;) class(models) ## [1] &quot;RasterBrick&quot; ## attr(,&quot;package&quot;) ## [1] &quot;raster&quot; models ## class : RasterBrick ## dimensions : 1293, 1251, 1617543, 6 (nrow, ncol, ncell, nlayers) ## resolution : 0.00141, 0.000898 (x, y) ## extent : -5.867338, -4.103428, 49.84596, 51.00708 (xmin, xmax, ymin, ymax) ## crs : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 ## source : memory ## names : tri, tpi, roughness, slope, aspect, flowdir ## min values : 2.289150e-02, -1.178207e+02, 0.000000e+00, 4.132828e-03, 6.612837e-04, 1.000000e+00 ## max values : 244.5606, 122.4477, 705.7529, 67.0107, 359.9989, 128.0000 plot(models) 4.5.3 Hillshade We can also make a hillshade raster and overlay the elevation data. We introduce a way of subsetting the raster stack/brick here using subset but you could also use slope &lt;- models$slope or other means we introduced at the beginning of this section: slope &lt;- subset(models, &quot;slope&quot;) # select slope aspect &lt;- subset(models, &quot;aspect&quot;) # select slope hill &lt;- hillShade(slope, aspect, 45, 270) plot(hill, col = grey(0:100/100), legend = FALSE) plot(elev_100m_WGS84, col = rainbow(25, alpha=0.35), add=TRUE) 4.6 Visualisation 4.6.1 Create a map Maps can be quickly created using leaflet and basemaps from OpenStreetMap or tiles from MapBox imagery can be imported to enhance the map: pal &lt;- colorNumeric(c(&quot;#FFFFCC&quot;, &quot;#41B6C4&quot;, &quot;#0C2C84&quot;), domain=c(0,500, na.rm=T), na.color = &quot;transparent&quot;, reverse = T) leaflet() %&gt;% addTiles() %&gt;% # OpenStreetMap base map addRasterImage(elev_100m_WGS84, colors = pal, opacity = 0.8) %&gt;% addLegend(pal = pal, values = c(0, 500), title = &quot;Cornwall Elevation&quot;) ## Warning in colors(.): Some values were outside the color scale and will be ## treated as NA The leaflet package is highly versatile and can do a lot more. You can explore more here. 4.6.2 Visualize in 3D We can also make an interative 3D plot of a RasterLayer. You can modifiy several parameters like the color palette or the elevation scale relative to x and y. library(rgl) library(rasterVis) plot3D(elev_100m_WGS84, zfac = 1, col=terrain.colors, rev=FALSE) # plot 3d with rgl 4.7 Saving raster data There are a number of ways to save your data to files. First let’s create an output folder if you don’t already have one: dir.create(&quot;output&quot;) ## Warning in dir.create(&quot;output&quot;): &#39;output&#39; already exists Now we can write our rasters as layers, stacks or write layers from stacks, using the writeRaster function: # A raster layer writeRaster(slope, filename=&quot;output/slope.tif&quot;, format=&quot;GTiff&quot;, overwrite=TRUE) # A layer from a raster stack/brick writeRaster(models[[1]], filename=&quot;output/tri&quot;, format=&quot;GTiff&quot;, overwrite=TRUE) # A whole stack/brick writeRaster(models, filename=&quot;output/models&quot;, format=&quot;GTiff&quot;, overwrite=TRUE) # A whole raster stack/brick by layer writeRaster(models, filename=paste(&quot;output/&quot;, names(models), sep = &quot;&quot;), format=&quot;GTiff&quot;, bylayer=T, overwrite=TRUE) Or you can write it to a KML file with a set colour palette: myPal &lt;- colorRampPalette(brewer.pal(9, &#39;Blues&#39;), alpha=TRUE) # palette KML(elev_100m_WGS84, &quot;output/elev_100m_WGS84.kml&quot;, col = myPal(100), overwrite = TRUE) "]
]
